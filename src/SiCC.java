/**
 *  Simple Compiler Compiler (SiCC)
 *  
 *  
 *  SiCC generates parser code based on a language's definition.
 *  
 *  A language is first defined by its tokens, followed by its grammar. These two definitions
 *  are written into their own files, which SiCC reads in to create the parser.
 *  
 *  The token definition file is translated into a tokenizer which the parser uses. As you
 *  will see below, it is possible to omit the token definition if you plan on building your
 *  own tokenizer for the parser, or to create only the tokenizer based on the definition. 
 *  
 *  
 *  SiCC is invoked with the following options
 * 
 *  	SiCC [--package packagename] [--prefix prefixname] <definitions>
 *  
 *  where
 *  
 *  	<definitions> = tokendef  grammardef
 *  				  | --tokenizer-only tokendef
 *  				  | --parser-only grammardef
 *  
 *  
 *  Arguments
 *  	--package			Defines a package that the generated classes should belong to
 *  
 *  	--prefix			Defines a prefix that is to be added to the beginning of all generated
 *  						classes. ex: A prefix of "BOB" would turn "Tokenizer" into "BOBTokenizer"
 *  
 *  	--tokenizer-only	Only generate a tokenizer based on tokendef
 *  
 *   	--parser-only		Only generate a parser based on grammardef
 *   
 *   	tokendef			The filename of the token definition file
 *   
 *   	grammardef			The filename of the grammar definition file
 *   
 *   
 *  Using Your Own Tokenizer
 *  	
 *  	If you choose to generate only a parser you must create your own tokenizer for the parser to use.
 *  	Your tokenizer must implement the iTokenizer interface that is generated by implementing the nextToken()
 *  	method that return a Token object. Your tokenizer must also return a Token with name "eof" when the end
 *  	of the stream has been read.
 *   	
 */

import java.io.*;

/**
 * Simple Compiler Compiler
 * 
 * @author Shane Smith <shane.smith.baz@gmail.com>
 */
public class SiCC {

	/**
	 * Constants used for the "only" variable
	 */
	private static final int TOKENIZER_ONLY = 1;
	private static final int PARSER_ONLY = 2;
	
	/**
	 * Holds the arguments
	 */
	private String[] args;
	
	/**
	 * Whether or not a --XXXX-ONLY option was set, see constants for values
	 */
	private int only = 0;
	
	/**
	 *  The prefix to be added to the classes
	 */
	private String prefix = "";
	
	/**
	 *  The package name in which all created classes belong
	 */
	private String packagename = "";
	
	/**
	 *  File objects created by file names passed by the arguments
	 */
	private File tokenFile, grammarFile;
	
	/**
	 *  Definition objects 
	 */
	private TokenizerDefinition tokendef;
	private GrammarDefinition grammardef;
	
	/**
	 * Main. Output classes based on given arguments.
	 * Exceptions are also taken care of.
	 */
	public static void main(String[] args) {
		
		try {			
			SiCC sicc = new SiCC(args);
			
			sicc.createClasses();
			
			System.out.println("SiCC finished with no errors.");
			
			System.exit(0);
		}
		catch (ArgumentParsingException e) {
			System.out.println("Arguments passed to SiCC are invalid: " + e);
			System.exit(1);
		}
		catch (TokenizerDefinitionException e) {
			System.out.println("Error in token definition file: " +  e);
			System.exit(1);
		}
		catch (GrammarDefinitionException e) {
			System.out.println("Error in grammar definition file: " + e);
			System.exit(1);
		}
		catch (Exception e) {
			e.printStackTrace();
			System.exit(1);
		}
		
	}
	
	/**
	 * Constructor. Parse given arguments and create token and/or grammar
	 * definition objects according to arguments.  
	 */
	protected SiCC(String[] args) throws ArgumentParsingException, TokenizerDefinitionException, GrammarDefinitionException, TokenizerException, IOException {
		this.args = args;
		
		// parse the arguments
		parseArgs();
		
		// create a token definition object if not "parser only" and if the definition file is valid
		if (only != PARSER_ONLY) {
			if (tokenFile == null) throw new ArgumentParsingException("Missing token definition file!");
			if (!tokenFile.isFile()) throw new ArgumentParsingException (tokenFile + " is not a valid file!");
			tokendef = new TokenizerDefinition(new FileReader(tokenFile));
		}

		// create a grammar definition object if not "tokenizer only" and if the definition file is valid		
		if (only != TOKENIZER_ONLY) {
			if (grammarFile == null) throw new ArgumentParsingException("Missing grammar definition file!");
			if (!grammarFile.isFile()) throw new ArgumentParsingException (grammarFile + " is not a valid file!");
			grammardef = new GrammarDefinition(new FileReader(grammarFile));
		}
		
	}
	
	/**
	 * Parse the arguments and set appropriate options/variables
	 */
	private void parseArgs() throws ArgumentParsingException {		
		
		for(int i = 0; i < args.length; i++) {
			
			if (args[i].startsWith("-")) { 
				// argument is an option
				
				if (tokenFile != null || grammarFile != null) {
					// definition files have been specified, cannot set more options
					throw new ArgumentParsingException("Cannot place options after file definitions.");
				}
				
				// switch through possible arguments
				if (args[i].equals("--tokenizer-only")) {
					
					if (only != 0) {
						throw new ArgumentParsingException("Cannot set TOKENIZER-ONLY, already defined as " + (only==TOKENIZER_ONLY?"TOKENIZER-ONLY":"PARSER-ONLY") + ".");
					}
					
					only = TOKENIZER_ONLY;
					
				}
				else if (args[i].equals("--parser-only")) {
					
					if (only != 0){
						throw new ArgumentParsingException("Cannot set PARSER-ONLY, already defined as " + (only==TOKENIZER_ONLY?"TOKENIZER-ONLY":"PARSER-ONLY") + ".");
					}
					
					only = PARSER_ONLY;
					
				}
				else if (args[i].equals("--package")) {
					// set package name to the next argument and check validity
					
					if (i == args.length-1) { // end of arguments
						throw new ArgumentParsingException("Package name not defined.");
					}
					
					packagename = args[++i];
					
					if (!packagename.matches("[a-zA-Z]\\w*")) { // must start with an alpha char, followed by any number of alphanumeric
						throw new ArgumentParsingException("Invalid package name, must start with an letter followed by only letters or numbers: \"" + packagename + "\"");
					}
					
				}
				else if (args[i].equals("--prefix")) {
					// set prefix to the next argument and check validity
					
					if (i == args.length-1) { // end of arguments
						throw new ArgumentParsingException("Prefix not defined.");
					}
					
					prefix = args[++i];
					
					if (!prefix.matches("[a-zA-Z]\\w*")) { // must start with an alpha char, followed by any number of alphanumeric
						throw new ArgumentParsingException("Invalid prefix: " + prefix);
					}
					
				}
				else {
					
					throw new ArgumentParsingException("Unknown option: " + args[i]);
					
				}
				
			} else { 
				// argument is a definition file
				
				switch(only) {
				case TOKENIZER_ONLY:
					
					if (tokenFile != null) {
						throw new ArgumentParsingException("Token file has already been defined.");
					}
					
					tokenFile = new File(args[i]);
					break;
					
				case PARSER_ONLY:

					if (grammarFile != null) {
						throw new ArgumentParsingException("Grammar file has already been defined.");
					}
					
					grammarFile = new File(args[i]);
					break;
					
				default:
					// token and grammar files defined one after the other.

					if (tokenFile == null) {
						tokenFile = new File(args[i]);
					}
					else if (grammarFile == null) {
						grammarFile = new File(args[i]);
					}
					else {
						throw new ArgumentParsingException("Token and Grammar files have already been defined.");
					}
						
				}
				
			}
			
		}		
		
	}
	
	/**
	 * Create and output the classes 
	 */
	public void createClasses() throws IOException {
		// needed always
		createTokenClass();
		createTokenizerInterface();
		createTokenizerExceptionClass();
		
		// create Tokenizer if token definition is set
		if (tokendef != null) {
			createTokenizerClass();
			createNoSuchTokenExceptionClass();
		}
		
		// create Parser (and others) if grammar definition is set
		if (grammardef != null) {
			createParserClass();
			createParserExceptionClass();
			createVisitorInterface();
			createASTNodeClasses();
		}
	}
	
	/**
	 *  Create Tokenizer class
	 */
	private void createTokenizerClass() throws IOException {
		PrintWriter out = getWriter(prefix + "Tokenizer.java");
		
		new TokenizerClassCreator(prefix, tokendef).output(out);
		
		out.close();
	}
	
	private void createTokenizerExceptionClass() throws IOException {
		String classname = prefix + "TokenizerException";
		
		PrintWriter out = getWriter(classname + ".java");
		
		out.println("public class " + classname + " extends Exception {");
		out.println("  private static final long serialVersionUID = 1L;");
		out.println("  private int lineNumber = -1, column = -1;");
		out.println("  public " + classname + " (Throwable cause) { super(cause); }");
		out.println("  public " + classname + " (String msg) { super(msg); }");
		out.println("  public " + classname + " (String msg, int lineNumber) { super(msg); this.lineNumber = lineNumber; }");
		out.println("  public " + classname + " (String msg, int lineNumber, int column) { this(msg, lineNumber); this.column = column; }");
		out.println("  public int getLineNumber() { return lineNumber; }");
		out.println("  public int getColumn() { return column; }");
		out.println("  public String toString() { return (lineNumber != -1 ? \"[line \" + lineNumber + (column != -1 ? \", col \" + column : \"\") + \"] \" : \"\") + getMessage(); }");
		out.println("} // end " + classname);
		
		out.close();
	}
	
	private void createNoSuchTokenExceptionClass() throws IOException {
		String classname = prefix + "NoSuchTokenException";
		String extendsclass = prefix + "TokenizerException";
		
		PrintWriter out = getWriter(classname + ".java");
		
		out.println("public class " + classname + " extends " + extendsclass + " {");
		out.println("  private static final long serialVersionUID = 1L;");
		out.println("  private String value;");
		out.println("  public " + classname + " (String value, int lineNumber, int column) { super(\"No such token: \" + value, lineNumber, column); this.value = value; }");
		out.println("  public String getValue() { return value; }");
		out.println("} // end " + classname);
		
		out.close();
	}
	
	/**
	 * Create Parser class
	 */
	private void createParserClass() throws IOException {
		PrintWriter out = getWriter(prefix + "Parser.java");
		
		new ParserClassCreator(prefix, grammardef).output(out);
		
		out.close();
	}
	
	private void createParserExceptionClass() throws IOException {
		String classname = prefix + "ParserException";
		
		PrintWriter out = getWriter(classname + ".java");
		
		out.println("public class " + classname + " extends Exception {");
		out.println("  private static final long serialVersionUID = 1L;");
		out.println("  private int lineNumber = -1, column = -1;");
		out.println("  public " + classname + " (String msg) { super(msg); }");
		out.println("  public " + classname + " (String msg, int lineNumber) { this(msg); this.lineNumber=lineNumber; }");
		out.println("  public " + classname + " (String msg, int lineNumber, int column) { this(msg, lineNumber); this.column=column; }");
		out.println("  public int getLineNumber() { return lineNumber; }");
		out.println("  public int getColumn() { return column; }");
		out.println("  public String toString() { return (lineNumber != -1 ? \"[line \" + lineNumber + (column != -1 ? \", col \" + column : \"\") + \"] \" : \"\") + getMessage(); }");
		out.println("}");
		
		out.close();
	}
	
	/**
	 * Create Token class
	 */
	private void createTokenClass() throws IOException {
		String classname = prefix + "Token";
		
		PrintWriter out = getWriter(classname + ".java");
		
		out.println("/**");
		out.println(" * A token returned by the tokenizer");
		out.println(" */");
		out.println("public class " + classname + " {");
		out.println("  public int line = -1, column = -1, type = 0;");
		out.println("  public String name, value;");
		out.println("  public " + classname + " (int t, String n, String v, int l, int c) { type=t; name=n; value=v; line=l; column=c; }");
		out.println("  public " + classname + " (int t, String n, String v, int l) { type=t; name=n; value=v; line=l; }");
		out.println("  public " + classname + " (int t, String n, String v) { type=t; name=n; value=v; }");
		out.println("  public " + classname + " (String n, String v, int l, int c) { name=n; value=v; line=l; column=c; }");
		out.println("  public " + classname + " (String n, String v, int l) { name=n; value=v; line=l; }");
		out.println("  public " + classname + " (String n, String v) { name=n; value=v; }");
		out.println("  public " + classname + " (String n) { name=n; }");
		out.println("  public String toString() { return (line != -1 ? \"(\" + line + \") \" : \"\") + name + (value != null ? \" => \" + value : \"\"); }");
		out.println("  public boolean is (String str) { return str.equals(name); }");
		out.println("} // end " + classname);
		
		out.close();
	}
	
	/**
	 * Create Visitor interface.
	 * 
	 * A visit method is defined for each node type: public Object visit(ASTXXXXNode node, Object data);
	 */
	private void createVisitorInterface() throws IOException {
		
		String interfacename = prefix + "Visitor";
		
		PrintWriter out = getWriter(interfacename + ".java");
		interfacename += "<X,Y>";
		
		out.println("/**");
		out.println(" * An interface to implement in order to traverse the resulting parse tree");
		out.println(" */");
		out.println("public interface " + interfacename + " {");
		
		out.println("  public X visit(" + prefix + "ASTNode node, Y data);"); // base node
		
		// for each rule (except sub-rules) output a visit method
		for (String rulename : grammardef.getRuleNames()) {
			if (!grammardef.getRules(rulename).get(0).isSubrule()) {
				String classname = prefix + "AST" + rulename + "Node";
				out.println("  public X visit(" + classname + " node, Y data);");
			}
		}
		String classname = prefix + "ASTToken";
		out.println("  public X visit(" + classname + " node, Y data);");
		
		out.println("} // end " + interfacename);
		
		out.close();
		
	}
	
	/**
	 * Create Tokenizer interface
	 */
	private void createTokenizerInterface() throws IOException {
		
		String interfacename = prefix + "iTokenizer";
		String tokenclassname = prefix + "Token";
		String exceptionname = prefix + "TokenizerException";
		
		PrintWriter out = getWriter(interfacename + ".java");
		
		out.println("public interface " + interfacename + "{");
		
		out.println("  public " + tokenclassname + " nextToken() throws " + exceptionname + ";");
		
		out.println("} // end " + interfacename);
		
		out.close();
		
	}
	
	/**
	 * Create ASTNode classes (both super and sub classes) 
	 */
	private void createASTNodeClasses() throws IOException {
		createASTNodeSuperClass();
		createASTNodeSubClasses();
	}
	
	/**
	 * Create ASTNode superclass
	 */
	private void createASTNodeSuperClass() throws IOException {
		String classname = prefix + "ASTNode";
		String visitorname = prefix + "Visitor<X,Y>";
		
		PrintWriter out = getWriter(classname + ".java");
		
		out.println("import java.util.ArrayList;");
		out.println();
		out.println("public class " + classname + " {"); out.println();
		out.println("  private " + prefix + "ASTNode parent;"); out.println();
		out.println("  private ArrayList<" + prefix + "ASTNode> children = new ArrayList<" + prefix + "ASTNode>();"); out.println();
		out.println("  private String name, value;"); out.println();
		out.println("  private boolean multi_child;"); out.println();
		out.println("  public " + classname + " (String n, String v, boolean m) { name=n; value=v; multi_child=m; }"); out.println();
		out.println("  public boolean isMultiChild() { return multi_child; }"); out.println();
		out.println("  public void addChild(" + prefix + "ASTNode node) { if (node.parent != null) throw new RuntimeException(\"Node already has parent, can't add as child\");  children.add(node); node.parent = this; }"); out.println();
		out.println("  public void removeChild(" + prefix + "ASTNode node) { children.remove(node); node.parent = null; }"); out.println();
		out.println("  public ArrayList<" + prefix + "ASTNode> getChildren() { return children; }"); out.println();
		out.println("  public " + prefix + "ASTNode getChild(int i) { return children.get(i); }"); out.println();
		out.println("  public int numChildren() { return children.size(); }"); out.println();
		out.println("  public String getName() { return name; }"); out.println();
		out.println("  public String getValue() { return value; }"); out.println();
		out.println("  public " + prefix + "ASTNode getParent() { return parent; }"); out.println();
		out.println("  public <X,Y> X accept(" + visitorname + " visitor, Y data) { return visitor.visit(this, data); }"); out.println();
		out.println("  public String toString() { if (value == null || value.isEmpty()) { return name; } else { return name + \" => \" + value; } }"); out.println();
		out.println("} // end " + classname);
		
		out.close();
	}

	/**
	 * Create ASTXXXXNode subclasses for each type
	 */
	private void createASTNodeSubClasses() throws IOException {
		
		String classname;
		
		String extendname = prefix + "ASTNode";
		String visitorname = prefix + "Visitor<X,Y>";
		
		PrintWriter out;
		
		// for each rule (except sub-rules) create ASTXXXXNode class
		for (String rulename : grammardef.getRuleNames()) {
			if (grammardef.getRules(rulename).get(0).isSubrule()) continue;
			
			classname = prefix + "AST" + rulename + "Node";
			
			out = getWriter(classname + ".java");
			
			out.println("public class " + classname + " extends " + extendname + " {");
			out.println("  public " + classname + " (String n, String v, boolean m) { super(n,v,m); }");
			out.println("  public <X,Y> X accept(" + visitorname + " visitor, Y data) { return visitor.visit(this, data); }"); out.println();
			out.println("} // end " + classname);
			
			out.close();
			
		}
		
		// ASTToken class implicitly needed
		classname = prefix + "ASTToken";
		
		out = getWriter(classname + ".java");
		
		out.println("public class " + classname + " extends " + extendname + " {");
		out.println("  public " + classname + " (String n, String v) { super(n,v,false); }" );
		out.println("  public <X,Y> X accept(" + visitorname + " visitor, Y data) { return visitor.visit(this, data); }"); out.println();
		out.println("}");
		
		out.close();
		
	}
	
	
	/**
	 * Returns a PrintWriter for the given file name (with package considerations)
	 */
	private PrintWriter getWriter(String filename) throws IOException {
		if (!packagename.isEmpty()) {
			File packagedir = new File(packagename);
			
			if (!packagedir.exists()) {
				boolean createdDir = packagedir.mkdir();
				
				if (!createdDir) {
					throw new IOException("Failed to create package directory \"" + packagename + "\" for unknown reasons.");
				}	
			}
			else if (packagedir.isFile()) {
				throw new IOException("Failed to create package directory \"" + packagename + "\", file exists.");
			}			
			
			filename = packagename + "/" + filename;
		}
		
		PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(filename)));
		
		if (!packagename.isEmpty()) {
			out.println("package " + packagename + ";");
			out.println();
		}
		
		return out;
	}
}
